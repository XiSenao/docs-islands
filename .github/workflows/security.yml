name: Security & Dependencies

env:
  NODE_VERSION: "22"

on:
  schedule:
    - cron: "0 2 * * *"
  workflow_dispatch:
  push:
    branches:
      - main
    paths:
      - "pnpm-lock.yaml"
  pull_request:
    paths:
      - "pnpm-lock.yaml"
      - "**/package.json"

# Minimum privilege principle - Job-level permission refinement
permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Secret detection
  secret-scan:
    name: Scan for Secrets
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read
      issues: write
    steps:
      # action/checkout@v5.0.0.
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8
        with:
          fetch-depth: 0

      - name: Run Gitleaks
        # gitleaks/gitleaks-action@v2.3.9.
        uses: gitleaks/gitleaks-action@ff98106e4c7b2bc287b24eaf42907196329070c7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Secret Alert Issue
        if: failure()
        # actions/github-script@v8.0.0.
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd7
        with:
          script: |
            const title = 'ğŸš¨ Secret Leak Detected';
            const body = `## ğŸ” Secret Scanning Alert

            Gitleaks has detected potential secrets in the repository.

            **Action Required**: Review the scan results and:
            1. Rotate any exposed credentials immediately
            2. Remove secrets from git history if needed
            3. Use environment variables or secret management tools

            **Scan Details**: Check the [workflow run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.
            `;

            // Check for existing open issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'security,secrets'
            });

            const existingIssue = issues.find(issue => issue.title.includes('Secret Leak Detected'));

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['security', 'secrets', 'critical', 'automated']
              });
            }

  # Fast security audit
  security-audit:
    name: Security Audit
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write # For creating security issues
    outputs:
      has_vulnerabilities: ${{ steps.audit.outputs.has_vulnerabilities }}
      critical_count: ${{ steps.audit.outputs.critical_count }}
      high_count: ${{ steps.audit.outputs.high_count }}
    steps:
      # action/checkout@v5.0.0.
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8

      - name: Setup Environment
        uses: ./.github/actions/setup-env
        with:
          node-version: ${{ env.NODE_VERSION }}
          frozen-lockfile: true

      - name: Cache Audit Results
        id: cache-audit
        # actions/cache@v4.3.0.
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830
        with:
          path: audit.json
          key: security-audit-${{ hashFiles('pnpm-lock.yaml') }}
          restore-keys: |
            security-audit-

      - name: Run Security Audit
        id: audit
        run: |
          set -euo pipefail  # Strict error handling

          echo "## ğŸ”’ Security Audit Report" > audit-report.md
          echo "Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> audit-report.md
          echo "" >> audit-report.md

          echo "### pnpm audit results:" >> audit-report.md

          if pnpm audit --json > audit.json 2>&1; then
            echo "âœ… No vulnerabilities found" >> audit-report.md
            echo "has_vulnerabilities=false" >> $GITHUB_OUTPUT
            echo "critical_count=0" >> $GITHUB_OUTPUT
            echo "high_count=0" >> $GITHUB_OUTPUT
          else
            if ! jq empty audit.json 2>/dev/null; then
              echo "âŒ Invalid audit output format" >> audit-report.md
              cat audit.json >> audit-report.md
              exit 1
            fi

            if jq -e '.advisories' audit.json >/dev/null 2>&1; then
              CRITICAL=$(jq '.advisories | map(select(.severity == "critical")) | length' audit.json)
              HIGH=$(jq '.advisories | map(select(.severity == "high")) | length' audit.json)
              MODERATE=$(jq '.advisories | map(select(.severity == "moderate")) | length' audit.json)
              LOW=$(jq '.advisories | map(select(.severity == "low")) | length' audit.json)

              echo "- ğŸ”´ Critical: $CRITICAL" >> audit-report.md
              echo "- ğŸŸ  High: $HIGH" >> audit-report.md
              echo "- ğŸŸ¡ Moderate: $MODERATE" >> audit-report.md
              echo "- ğŸŸ¢ Low: $LOW" >> audit-report.md
              echo "" >> audit-report.md

              echo "has_vulnerabilities=true" >> $GITHUB_OUTPUT
              echo "critical_count=$CRITICAL" >> $GITHUB_OUTPUT
              echo "high_count=$HIGH" >> $GITHUB_OUTPUT

              echo "### Vulnerability Details:" >> audit-report.md
              jq -r '.advisories[] | "#### [\(.title)](\(.url))\n- **Severity**: \(.severity)\n- **Package**: \(.module_name)\n- **Patched versions**: \(.patched_versions)\n- **Recommendation**: \(.recommendation)\n"' audit.json >> audit-report.md || true
            else
              echo "âš ï¸ Unexpected audit output format" >> audit-report.md
              jq '.' audit.json >> audit-report.md
            fi
          fi

      - name: Upload Audit Report
        if: always()
        # actions/upload-artifact@v4.6.2.
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa024
        with:
          name: security-audit-report
          path: audit-report.md
          retention-days: 30

      - name: Create Security Issue
        if: steps.audit.outputs.has_vulnerabilities == 'true' && (steps.audit.outputs.critical_count != '0' || steps.audit.outputs.high_count != '0')
        # actions/github-script@v8.0.0.
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('audit-report.md', 'utf8');
            const critical = '${{ steps.audit.outputs.critical_count }}';
            const high = '${{ steps.audit.outputs.high_count }}';

            const title = `ğŸš¨ Critical Security Vulnerabilities Detected (${critical} Critical, ${high} High)`;

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'security'
            });

            const existingIssue = issues.find(issue =>
              issue.title.includes('Critical Security Vulnerabilities')
            );

            if (existingIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `## ğŸ“… Updated Scan Results\n\n${report}`
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: report + '\n\n---\n\n**Action Required**: Please review and address these vulnerabilities.\n\nRun `pnpm audit fix` to attempt automatic fixes.',
                labels: ['security', 'critical', 'automated']
              });
            }

  # Dependency update detection
  dependency-updates:
    name: Check for Updates
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    outputs:
      updates_available: ${{ steps.outdated.outputs.updates_available }}
    steps:
      # action/checkout@v5.0.0.
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8

      - name: Setup Environment
        uses: ./.github/actions/setup-env
        with:
          node-version: 22
          frozen-lockfile: true

      - name: Check Outdated Packages
        id: outdated
        run: |
          set -euo pipefail

          echo "## ğŸ“¦ Dependency Update Report" > update-report.md
          echo "Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> update-report.md
          echo "" >> update-report.md

          # Check outdated packages
          echo "### Outdated Dependencies:" >> update-report.md

          if pnpm outdated --format json > outdated.json 2>&1; then
            echo "All dependencies are up to date! âœ…" >> update-report.md
            echo "updates_available=0" >> $GITHUB_OUTPUT
          else
            # Validate JSON format
            if ! jq empty outdated.json 2>/dev/null; then
              echo "âš ï¸ Failed to parse outdated packages" >> update-report.md
              echo "updates_available=0" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo '```json' >> update-report.md
            jq '.' outdated.json >> update-report.md
            echo '```' >> update-report.md
            echo "" >> update-report.md

            # Count packages needing updates
            TOTAL_UPDATES=$(jq 'to_entries | length' outdated.json 2>/dev/null || echo "0")
            MAJOR_UPDATES=$(jq '[to_entries[] | select(.value.current != .value.latest and (.value.latest | split(".")[0]) != (.value.current | split(".")[0]))] | length' outdated.json 2>/dev/null || echo "0")

            echo "updates_available=$TOTAL_UPDATES" >> $GITHUB_OUTPUT
            echo "**Total packages needing updates: $TOTAL_UPDATES**" >> update-report.md
            echo "**Major version updates: $MAJOR_UPDATES**" >> update-report.md

            # Categorized display of updates
            echo "" >> update-report.md
            echo "#### ğŸ”´ Major Updates (Breaking Changes Expected):" >> update-report.md
            jq -r 'to_entries[] | select(.value.current != .value.latest and (.value.latest | split(".")[0]) != (.value.current | split(".")[0])) | "- **\(.key)**: \(.value.current) â†’ \(.value.latest)"' outdated.json >> update-report.md || echo "None" >> update-report.md

            echo "" >> update-report.md
            echo "#### ğŸŸ¡ Minor/Patch Updates:" >> update-report.md
            jq -r 'to_entries[] | select(.value.current != .value.latest and (.value.latest | split(".")[0]) == (.value.current | split(".")[0])) | "- **\(.key)**: \(.value.current) â†’ \(.value.latest)"' outdated.json >> update-report.md || echo "None" >> update-report.md
          fi

      - name: Upload Update Report
        if: always()
        # actions/upload-artifact@v4.6.2.
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa024
        with:
          name: dependency-update-report
          path: update-report.md
          retention-days: 30

      - name: Create Update Issue
        # Fixed condition judgment - Use string comparison
        if: steps.outdated.outputs.updates_available != '' && steps.outdated.outputs.updates_available != '0'
        # actions/github-script@v8.0.0.
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('update-report.md', 'utf8');
            const updateCount = '${{ steps.outdated.outputs.updates_available }}';

            const title = `ğŸ¤– Dependency Updates Available (${updateCount} packages) - ${new Date().toISOString().split('T')[0]}`;
            const body = report + '\n\n---\n\n**To update dependencies, run:**\n```bash\npnpm update --interactive\n```\n\n**For major updates, review breaking changes first:**\n```bash\npnpm outdated\n```';

            // Check for existing same issue
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'dependencies'
            });

            const existingIssue = issues.find(issue =>
              issue.title.includes('Dependency Updates Available')
            );

            if (existingIssue) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `## ğŸ“… Updated Dependency Report\n\n${report}`
              });
            } else {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['dependencies', 'automated']
              });
            }

  # License compliance check
  license-check:
    name: License Compliance
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      has_incompatible: ${{ steps.license.outputs.has_incompatible }}
    steps:
      # action/checkout@v5.0.0.
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8

      - name: Setup Environment
        uses: ./.github/actions/setup-env
        with:
          node-version: 22
          frozen-lockfile: true

      - name: Check Licenses
        id: license
        run: |
          set -euo pipefail

          echo "## ğŸ“œ License Compliance Report" > license-report.md
          echo "Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> license-report.md
          echo "" >> license-report.md

          # Get licenses for all production dependencies
          echo "### Production Dependencies Licenses:" >> license-report.md

          if pnpm licenses list --prod --json > licenses.json 2>&1; then
            # Validate JSON format
            if ! jq empty licenses.json 2>/dev/null; then
              echo "âš ï¸ Failed to parse license data" >> license-report.md
              exit 1
            fi

            # Check data structure
            if jq -e 'type == "array"' licenses.json >/dev/null 2>&1; then
              # Count each license type
              echo "" >> license-report.md
              echo "| License | Count |" >> license-report.md
              echo "|---------|-------|" >> license-report.md

              jq -r 'group_by(.license) | .[] | "| \(.[0].license // "Unknown") | \(length) |"' licenses.json >> license-report.md

              # Check for incompatible licenses
              INCOMPATIBLE=$(jq '[.[] | select(.license | test("GPL|AGPL|LGPL|SSPL"; "i"))] | length' licenses.json 2>/dev/null || echo "0")

              echo "has_incompatible=$INCOMPATIBLE" >> $GITHUB_OUTPUT

              if [ "$INCOMPATIBLE" -gt 0 ]; then
                echo "" >> license-report.md
                echo "âš ï¸ **Warning**: Found $INCOMPATIBLE packages with potentially incompatible licenses" >> license-report.md
                echo "" >> license-report.md
                echo "### Packages with restrictive licenses:" >> license-report.md
                jq -r '.[] | select(.license | test("GPL|AGPL|LGPL|SSPL"; "i")) | "- **\(.name)@\(.version)**: \(.license)"' licenses.json >> license-report.md
              else
                echo "" >> license-report.md
                echo "âœ… All licenses are compatible" >> license-report.md
              fi
            else
              echo "âš ï¸ Unexpected license data format" >> license-report.md
              jq '.' licenses.json >> license-report.md
            fi
          else
            echo "âŒ Failed to retrieve license information" >> license-report.md
            exit 1
          fi

      - name: Upload License Report
        if: always()
        # actions/upload-artifact@v4.6.2.
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa024
        with:
          name: license-report
          path: license-report.md
          retention-days: 90

  # SBOM (Software Bill of Materials) generation
  generate-sbom:
    name: Generate SBOM
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      # action/checkout@v5.0.0.
      - uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8

      - name: Setup Environment
        uses: ./.github/actions/setup-env
        with:
          node-version: 22
          frozen-lockfile: true

      # Build project first to ensure all local dependencies are available
      - name: Build Packages
        run: pnpm build
        env:
          NODE_ENV: production
          CI: true

      - name: Generate SBOM with Syft
        # anchore/sbom-action@v0.20.6.
        uses: anchore/sbom-action@8e94d75ddd33f69f691467e42275782e4bfefe84
        with:
          path: .
          output-file: sbom.json
          format: cyclonedx-json
          upload-artifact: false # Manual upload

      - name: Validate and Report SBOM
        run: |
          set -euo pipefail

          echo "âœ… SBOM generated successfully"

          # Validate SBOM format
          if ! jq empty sbom.json 2>/dev/null; then
            echo "âŒ Invalid SBOM format"
            exit 1
          fi

          # Output statistics
          COMPONENT_COUNT=$(jq '.components | length' sbom.json 2>/dev/null || echo "0")
          echo "ğŸ“Š SBOM contains $COMPONENT_COUNT components"

          # Display first few components
          echo ""
          echo "ğŸ“¦ Top components:"
          jq -r '.components[:5] | .[] | "  - \(.name)@\(.version)"' sbom.json || true

      - name: Upload SBOM
        # actions/upload-artifact@v4.6.2.
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa024
        with:
          name: sbom
          path: sbom.json
          retention-days: 90

      - name: Upload SBOM to Release
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        # actions/upload-artifact@v4.6.2.
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa024
        with:
          name: sbom-latest
          path: sbom.json
          retention-days: 365

      # - name: Submit SBOM to Dependency Track
      #   if: github.ref == 'refs/heads/main'
      #   run: |
      #     # For supply chain management with Dependency Track
      #     curl -X POST "${{ secrets.DEPENDENCY_TRACK_URL }}/api/v1/bom" \
      #       -H "X-API-Key: ${{ secrets.DEPENDENCY_TRACK_KEY }}" \
      #       -H "Content-Type: application/json" \
      #       -d @sbom.json

  # Consolidated report
  summary:
    name: Security Summary
    runs-on: ubuntu-latest
    needs:
      [
        secret-scan,
        security-audit,
        dependency-updates,
        license-check,
        generate-sbom,
      ]
    permissions:
      contents: read
    if: always()
    steps:
      - name: Download All Artifacts
        # actions/download-artifact@v5.0.0.
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0
        with:
          path: reports

      - name: Create Comprehensive Summary
        # actions/github-script@v8.0.0.
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const summary = [];
            summary.push('# ğŸ›¡ï¸ Security & Compliance Summary\n');
            summary.push(`**Date**: ${new Date().toISOString()}\n`);
            summary.push(`**Workflow**: ${context.workflow}\n`);
            summary.push(`**Run**: [#${context.runNumber}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})\n\n`);

            // Job status
            summary.push('## ğŸ“‹ Job Status\n');
            const jobs = {
              'Secret Scan': '${{ needs.secret-scan.result }}',
              'Security Audit': '${{ needs.security-audit.result }}',
              'Dependency Updates': '${{ needs.dependency-updates.result }}',
              'License Check': '${{ needs.license-check.result }}',
              'SBOM Generation': '${{ needs.generate-sbom.result }}'
            };

            for (const [name, status] of Object.entries(jobs)) {
              const icon = status === 'success' ? 'âœ…' : status === 'failure' ? 'âŒ' : 'â­ï¸';
              summary.push(`- ${icon} **${name}**: ${status}\n`);
            }

            // Security audit results
            summary.push('\n## ğŸ”’ Security Audit Results\n');
            const hasVulnerabilities = '${{ needs.security-audit.outputs.has_vulnerabilities }}';
            const criticalCount = '${{ needs.security-audit.outputs.critical_count }}' || '0';
            const highCount = '${{ needs.security-audit.outputs.high_count }}' || '0';

            if (hasVulnerabilities === 'true') {
              summary.push(`âš ï¸ **Vulnerabilities Found**:\n`);
              summary.push(`- ğŸ”´ Critical: ${criticalCount}\n`);
              summary.push(`- ğŸŸ  High: ${highCount}\n`);
            } else {
              summary.push('âœ… No critical vulnerabilities detected\n');
            }

            // Dependency updates
            summary.push('\n## ğŸ“¦ Dependency Updates\n');
            const updatesAvailable = '${{ needs.dependency-updates.outputs.updates_available }}' || '0';
            if (updatesAvailable !== '0') {
              summary.push(`ğŸ“Š ${updatesAvailable} packages have updates available\n`);
            } else {
              summary.push('âœ… All dependencies are up to date\n');
            }

            // License compliance
            summary.push('\n## ğŸ“œ License Compliance\n');
            const hasIncompatible = '${{ needs.license-check.outputs.has_incompatible }}' || '0';
            if (hasIncompatible !== '0') {
              summary.push(`âš ï¸ ${hasIncompatible} packages with restrictive licenses found\n`);
            } else {
              summary.push('âœ… All licenses are compatible\n');
            }

            // Read report contents
            summary.push('\n## ğŸ“„ Detailed Reports\n');

            try {
              const reportsDir = 'reports';
              if (fs.existsSync(reportsDir)) {
                const artifacts = fs.readdirSync(reportsDir);
                for (const artifact of artifacts) {
                  const artifactPath = path.join(reportsDir, artifact);
                  if (fs.statSync(artifactPath).isDirectory()) {
                    const files = fs.readdirSync(artifactPath);
                    for (const file of files) {
                      if (file.endsWith('.md')) {
                        summary.push(`\n### ğŸ“‹ ${artifact}\n`);
                        const content = fs.readFileSync(path.join(artifactPath, file), 'utf8');
                        summary.push(content + '\n');
                      }
                    }
                  }
                }
              }
            } catch (error) {
              summary.push(`\nâš ï¸ Could not read report details: ${error.message}\n`);
            }

            // Write job summary
            await core.summary
              .addRaw(summary.join(''))
              .write();

            // Set failure status for serious issues
            if (hasVulnerabilities === 'true' && (criticalCount !== '0' || highCount !== '0')) {
              core.setFailed(`Found ${criticalCount} critical and ${highCount} high severity vulnerabilities`);
            }
